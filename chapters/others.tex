\chapter{非核心函数分析}

\minitoc

\section{SKB}


\section{Inet}

\section{TCP层}


    \subsection{\mintinline{C}{tcp_sk}}

    \mintinline{c}{TCP_INC_STATS_BH}

    \mintinline{c}{rcu_read_unlock} 出现在\mintinline{c}{tcp_make_synack}中于MD5相关的部分。
    
    \mintinline{c}{net_xmit_eval}   定时器？？

\subsection{\mintinline{c}{__tcp_push_pending_frames}}
\begin{minted}[linenos]{c}
/* 将等待在队列中的包全部发出。 */
void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
                               int nonagle)
{
        /* 如果此时连接已经关闭了，那么直接返回。*/
        if (unlikely(sk->sk_state == TCP_CLOSE))
                return;

        /* 关闭nagle算法，将剩余的部分发送出去。 */
        if (tcp_write_xmit(sk, cur_mss, nonagle, 0,
                           sk_gfp_atomic(sk, GFP_ATOMIC)))
                tcp_check_probe_timer(sk);
}
\end{minted}

\subsection{tcp\_init\_nondata\_skb}
该函数提供了初始化不含数据的skb的功能。函数原型如下：
\begin{minted}[linenos]{c}
tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags);
\end{minted}

\begin{description}
  \item[skb] 待初始化的\mintinline{c}{sk_buff}。
  \item[seq] 序号
  \item[flags] 标志位
\end{description}

\begin{minted}[linenos]{c}
static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
{
        /* 设置校验码 */
        skb->ip_summed = CHECKSUM_PARTIAL;
        skb->csum = 0;

        /* 设置标志位 */
        TCP_SKB_CB(skb)->tcp_flags = flags;
        TCP_SKB_CB(skb)->sacked = 0;

        tcp_skb_pcount_set(skb, 1);

        /* 设置起始序号 */
        TCP_SKB_CB(skb)->seq = seq;
        if (flags & (TCPHDR_SYN | TCPHDR_FIN))
                seq++;
        TCP_SKB_CB(skb)->end_seq = seq;
}
\end{minted}

\subsection{before()和after()}
在一些需要判断序号前后的地方出现了\mintinline{c}{before()}和\mintinline{c}{after()}
这两个函数。这两个函数的定义如下
\begin{minted}[linenos]{c}
/* include/net/tcp.h
 * 比较两个无符号32位整数
 */
static inline bool before(__u32 seq1, __u32 seq2)
{
        return (__s32)(seq1-seq2) < 0;
}
#define after(seq2, seq1)       before(seq1, seq2)
\end{minted}
可以看到，这两个函数实际上就是将两个数直接相减。之所以要单独弄个函数应该是为了避免强制转型
造成影响。序号都是32位无符号整型。


