\chapter{非核心函数分析}

\minitoc

\section{SKB相关函数和宏}

\section{TCP相关函数和宏}
\subsection{tcp\_init\_nondata\_skb}
该函数提供了初始化不含数据的skb的功能。函数原型如下：
\begin{minted}[linenos]{c}
tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags);
\end{minted}

\begin{description}
  \item[skb] 待初始化的\mintinline{c}{sk_buff}。
  \item[seq] 序号
  \item[flags] 标志位
\end{description}

\begin{minted}[linenos]{c}
static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
{
        /* 设置校验码 */
        skb->ip_summed = CHECKSUM_PARTIAL;
        skb->csum = 0;

        /* 设置标志位 */
        TCP_SKB_CB(skb)->tcp_flags = flags;
        TCP_SKB_CB(skb)->sacked = 0;

        tcp_skb_pcount_set(skb, 1);

        /* 设置起始序号 */
        TCP_SKB_CB(skb)->seq = seq;
        if (flags & (TCPHDR_SYN | TCPHDR_FIN))
                seq++;
        TCP_SKB_CB(skb)->end_seq = seq;
}
\end{minted}

\begin{minted}[linenos]{c}
/* 初始化一个TCP连接 */
tcp_connect_init(struct sock *sk);
/* 结束一个TCP连接 */
tcp_finish_connect(struct sock *sk, NULL);
/* 分配一个skb缓存
 * 其中，gfp是分配内存的模式，这个和Linux的内存管理有关。
 * sock结构体中的sk_allocation指定了这一模式。
 * force_schedule根据分析sk_stream_alloc_skb代码，
 * 可知，这个是用来强制内存分配分配到精确满足大小要求的内存。
 */
sk_stream_alloc_skb(struct sock *sk, int size,
gfp_t gfp, bool force_schedule);
/* 将skb加入到发送队列中。（此处是否和滑动窗口有关？） */ 
tcp_connect_queue_skb(struct sock *sk, struct sk_buff *skb);
/* 该函数是真正实现将队列中的TCP包发送出去的功能。
 * 在发送和重传过程中均会用到该函数。此处所有的SKB是无头部(headerless)的
 * 在该函数中，我们需要构造TCP头部，然后将包发给IP层，以使得
 * 该报文能够真正发送出去。
 */
tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
gfp_t gfp_mask);

/* 重置定时器，what处可以接收的值为ICSK_TIME_RETRANS,ICSK_TIME_EARLY_RETRANS,
 * ICSK_TIME_PROBE0,ICSK_TIME_LOSS_PROBE。其中when是超时时间，
 * max_when是系统所允许的最大超时时间。
 */
inet_csk_reset_xmit_timer(struct sock *sk, const int what,
                          unsigned long when,
                          const unsigned long max_when);
\end{minted}

\section{辅助函数}
有些小函数是用于辅助一些很底层的功能的，这里单独列出来。
                unlikely
\subsection{字节序}
CPU分为大端和小端两种。而在网络传输的过程中，大小端的不一致会带来问题。
因此，网络协议中对于字节序都有明确规定。一般采用大端序。

Linux中，对于这一部分的支持放在了\mintinline{text}{include/linux/byteorder/generic.h}
中。而实现，则交由体系结构相关的代码来完成。

\begin{minted}[linenos]{c}
/* 下面的函数用于进行对16位整型或者32位整型在网络传输格式和本地格式之间的转换。
 */
ntohl(__u32 x)
ntohs(__u16 x)
htonl(__u32 x)
htons(__u16 x)
\end{minted}

上面函数的命名规则是末尾的l代表32位，s代表16位。n代表network，h代表host。
根据命名规则，不难知道函数的用途。比如htons就是从本地的格式转换的网络传输用的格式，
转换的是16位整数。
