\chapter{非核心函数分析}

\minitoc

\section{SKB}
    \subsection{\mintinline{C}{skb_transport_header}}
        
        该函数位于\mintinline{C}{/include/linux/skbuff.h}中，其功能是根据skb得到其tcphdr的偏移。
\begin{minted}[linenos]{C}
static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
    return skb->head + skb->transport_header;
}
\end{minted}

        其中，\mintinline{C}{skb->head}指向缓存区的头部。\mintinline{C}{skb->transport_heade}为传输层相对于缓冲区头部的偏移。

\section{Inet}
    \subsection{\mintinline{C}{inet_rsk}}

        该函数位于\mintinline{C}{/include/net/inet__sock.h}中，主要的目的就是进行类型转换，将一个\mintinline{C}{request_sock}类型的变量转为\mintinline{C}{inet_request_sock}。

\begin{minted}[linenos]{C}
static inline struct inet_request_sock *inet_rsk(const struct request_sock *sk)
{
    return (struct inet_request_sock *)sk;
}
\end{minted}
    
    \subsection{\mintinline{C}{inet_csk}}
        该函数位于\mintinline{C}{/include/net/inet_connection_sock.h}中，主要的目的就是进行类型转换，将一个sock类型的变量转为\mintinline{C}{inet_connection_sock}。

\begin{minted}[linenos]{C}
static inline struct inet_connection_sock *inet_csk(const struct sock *sk)
{
    return (struct inet_connection_sock *)sk;
}
\end{minted}

\section{TCP层}
    \subsection{\mintinline{C}{tcp_hdr}}

        该函数位于\mintinline{C}{/include/linux/tcp.h}中，主要目的就是将\mintinline{C}{sk_buff}类型的变量转化为\mintinline{C}{tcphdr};
\begin{minted}[linenos]{C}
static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
{
    return (struct tcphdr *)skb_transport_header(skb);
}
\end{minted}

    \subsection{\mintinline{C}{tcp_sk}}

    \mintinline{c}{TCP_INC_STATS_BH}

    \mintinline{c}{rcu_read_unlock} 出现在\mintinline{c}{tcp_make_synack}中于MD5相关的部分。
    
    \mintinline{c}{net_xmit_eval}   定时器？？

\subsection{\mintinline{c}{__tcp_push_pending_frames}}
\begin{minted}[linenos]{c}
/* 将等待在队列中的包全部发出。 */
void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
                               int nonagle)
{
        /* 如果此时连接已经关闭了，那么直接返回。*/
        if (unlikely(sk->sk_state == TCP_CLOSE))
                return;

        /* 关闭nagle算法，将剩余的部分发送出去。 */
        if (tcp_write_xmit(sk, cur_mss, nonagle, 0,
                           sk_gfp_atomic(sk, GFP_ATOMIC)))
                tcp_check_probe_timer(sk);
}
\end{minted}

\subsection{tcp\_init\_nondata\_skb}
该函数提供了初始化不含数据的skb的功能。函数原型如下：
\begin{minted}[linenos]{c}
tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags);
\end{minted}

\begin{description}
  \item[skb] 待初始化的\mintinline{c}{sk_buff}。
  \item[seq] 序号
  \item[flags] 标志位
\end{description}

\begin{minted}[linenos]{c}
static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
{
        /* 设置校验码 */
        skb->ip_summed = CHECKSUM_PARTIAL;
        skb->csum = 0;

        /* 设置标志位 */
        TCP_SKB_CB(skb)->tcp_flags = flags;
        TCP_SKB_CB(skb)->sacked = 0;

        tcp_skb_pcount_set(skb, 1);

        /* 设置起始序号 */
        TCP_SKB_CB(skb)->seq = seq;
        if (flags & (TCPHDR_SYN | TCPHDR_FIN))
                seq++;
        TCP_SKB_CB(skb)->end_seq = seq;
}
\end{minted}

\subsection{before()和after()}
在一些需要判断序号前后的地方出现了\mintinline{c}{before()}和\mintinline{c}{after()}
这两个函数。这两个函数的定义如下
\begin{minted}[linenos]{c}
/* include/net/tcp.h
 * 比较两个无符号32位整数
 */
static inline bool before(__u32 seq1, __u32 seq2)
{
        return (__s32)(seq1-seq2) < 0;
}
#define after(seq2, seq1)       before(seq1, seq2)
\end{minted}
可以看到，这两个函数实际上就是将两个数直接相减。之所以要单独弄个函数应该是为了避免强制转型
造成影响。序号都是32位无符号整型。


