\chapter{非核心函数分析}

\minitoc

\section{SKB相关函数和宏}

\section{TCP相关函数和宏}
    \mintinline{c}{tcp_hdr}

    \mintinline{c}{TCP_INC_STATS_BH}

    \mintinline{c}{rcu_read_unlock} 出现在\mintinline{c}{tcp_make_synack}中于MD5相关的部分。
    
    \mintinline{c}{net_xmit_eval}   定时器？？
\subsection{tcp\_init\_nondata\_skb}
该函数提供了初始化不含数据的skb的功能。函数原型如下：
\begin{minted}[linenos]{c}
tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags);
\end{minted}

\begin{description}
  \item[skb] 待初始化的\mintinline{c}{sk_buff}。
  \item[seq] 序号
  \item[flags] 标志位
\end{description}

\begin{minted}[linenos]{c}
static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
{
        /* 设置校验码 */
        skb->ip_summed = CHECKSUM_PARTIAL;
        skb->csum = 0;

        /* 设置标志位 */
        TCP_SKB_CB(skb)->tcp_flags = flags;
        TCP_SKB_CB(skb)->sacked = 0;

        tcp_skb_pcount_set(skb, 1);

        /* 设置起始序号 */
        TCP_SKB_CB(skb)->seq = seq;
        if (flags & (TCPHDR_SYN | TCPHDR_FIN))
                seq++;
        TCP_SKB_CB(skb)->end_seq = seq;
}
\end{minted}

\begin{minted}[linenos]{c}
/* 初始化一个TCP连接 */
tcp_connect_init(struct sock *sk);
/* 结束一个TCP连接 */
tcp_finish_connect(struct sock *sk, NULL);
/* 分配一个skb缓存
 * 其中，gfp是分配内存的模式，这个和Linux的内存管理有关。
 * sock结构体中的sk_allocation指定了这一模式。
 * force_schedule根据分析sk_stream_alloc_skb代码，
 * 可知，这个是用来强制内存分配分配到精确满足大小要求的内存。
 */
sk_stream_alloc_skb(struct sock *sk, int size,
gfp_t gfp, bool force_schedule);
/* 将skb加入到发送队列中。（此处是否和滑动窗口有关？） */ 
tcp_connect_queue_skb(struct sock *sk, struct sk_buff *skb);
/* 该函数是真正实现将队列中的TCP包发送出去的功能。
 * 在发送和重传过程中均会用到该函数。此处所有的SKB是无头部(headerless)的
 * 在该函数中，我们需要构造TCP头部，然后将包发给IP层，以使得
 * 该报文能够真正发送出去。
 */
tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
gfp_t gfp_mask);

/* 重置定时器，what处可以接收的值为ICSK_TIME_RETRANS,ICSK_TIME_EARLY_RETRANS,
 * ICSK_TIME_PROBE0,ICSK_TIME_LOSS_PROBE。其中when是超时时间，
 * max_when是系统所允许的最大超时时间。
 */
inet_csk_reset_xmit_timer(struct sock *sk, const int what,
                          unsigned long when,
                          const unsigned long max_when);
\end{minted}

\section{辅助函数}
有些小函数是用于辅助一些很底层的功能的，这里单独列出来。

\subsection{分支预测优化}
现代处理器均为流水线结构。而分支语句可能导致流水线断流。因此，很多处理器均有分支预测的功能。
然而，分支预测失败所导致的惩罚也是相对高昂的。为了提升性能，Linux的很多分支判断中都使用了
\mintinline{c}{likely()}和\mintinline{c}{unlikely()}这组宏定义来人工指示编译器，哪些
分支出现的概率极高，以便编译器进行优化。

这里有两种定义，一种是开启了分支语句分析相关的选项时，内核会采用下面的一种定义
\begin{minted}[linenos]{c}
/* include/linux/compiler.h
 * 采用__builtin_constant_p(x)来忽略常量表达式。
 */
# ifndef likely
#  define likely(x)     (__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 1))
# endif
# ifndef unlikely
#  define unlikely(x)   (__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 0))
# endif
\end{minted}
在该定义下，\mintinline{c}{__branch_check__}用于跟踪分支结果并更新统计数据。

如果不开启该选项，则定义得较为简单：
\begin{minted}[linenos]{c}
# define likely(x)      __builtin_expect(!!(x), 1)
# define unlikely(x)    __builtin_expect(!!(x), 0)
\end{minted}
其中\mintinline{c}{__builtin_expect}是GCC的内置函数，用于指示编译器，该条件语句最可能的结果是什么。

\subsection{字节序}
CPU分为大端和小端两种。而在网络传输的过程中，大小端的不一致会带来问题。
因此，网络协议中对于字节序都有明确规定。一般采用大端序。

Linux中，对于这一部分的支持放在了\mintinline{text}{include/linux/byteorder/generic.h}
中。而实现，则交由体系结构相关的代码来完成。

\begin{minted}[linenos]{c}
/* 下面的函数用于进行对16位整型或者32位整型在网络传输格式和本地格式之间的转换。
 */
ntohl(__u32 x)
ntohs(__u16 x)
htonl(__u32 x)
htons(__u16 x)
\end{minted}

上面函数的命名规则是末尾的l代表32位，s代表16位。n代表network，h代表host。
根据命名规则，不难知道函数的用途。比如htons就是从本地的格式转换的网络传输用的格式，
转换的是16位整数。
