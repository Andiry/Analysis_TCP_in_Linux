\chapter{非核心函数分析}

\minitoc

\section{SKB}
	\subsection{\mintinline{C}{skb_transport_header}}
		
		该函数位于\mintinline{C}{/include/linux/skbuff.h}中，其功能是根据skb得到其tcphdr的偏移。
\begin{minted}[linenos]{C}
static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
}
\end{minted}

		其中，\mintinline{C}{skb->head}指向缓存区的头部。\mintinline{C}{skb->transport_heade}为传输层相对于缓冲区头部的偏移。

\section{Inet}
	\subsection{\mintinline{C}{inet_csk}}
		该函数位于\mintinline{C}{/include/net/inet_connection_sock.h}中，主要的目的就是进行类型转换，将一个sock类型的变量转为\mintinline{C}{inet_connection_sock}。\textbf{问题待解决。}

\begin{minted}[linenos]{C}
static inline struct inet_connection_sock *inet_csk(const struct sock *sk)
{
	return (struct inet_connection_sock *)sk;
}
\end{minted}

\section{TCP层}
	\subsection{\mintinline{C}{tcp_hdr}}

		该函数位于\mintinline{C}{/include/linux/tcp.h}中，主要目的就是将\mintinline{C}{sk_buff}类型的变量转化为\mintinline{C}{tcphdr};
\begin{minted}[linenos]{C}
static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
{
	return (struct tcphdr *)skb_transport_header(skb);
}
\end{minted}
	\mintinline{c}{TCP_INC_STATS_BH}

	\mintinline{c}{rcu_read_unlock} 出现在\mintinline{c}{tcp_make_synack}中于MD5相关的部分。
	
	\mintinline{c}{net_xmit_eval}	定时器？？
\subsection{tcp\_init\_nondata\_skb}
该函数提供了初始化不含数据的skb的功能。函数原型如下：
\begin{minted}[linenos]{c}
tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags);
\end{minted}

\begin{description}
  \item[skb] 待初始化的\mintinline{c}{sk_buff}。
  \item[seq] 序号
  \item[flags] 标志位
\end{description}

\begin{minted}[linenos]{c}
static void tcp_init_nondata_skb(struct sk_buff *skb, u32 seq, u8 flags)
{
        /* 设置校验码 */
        skb->ip_summed = CHECKSUM_PARTIAL;
        skb->csum = 0;

        /* 设置标志位 */
        TCP_SKB_CB(skb)->tcp_flags = flags;
        TCP_SKB_CB(skb)->sacked = 0;

        tcp_skb_pcount_set(skb, 1);

        /* 设置起始序号 */
        TCP_SKB_CB(skb)->seq = seq;
        if (flags & (TCPHDR_SYN | TCPHDR_FIN))
                seq++;
        TCP_SKB_CB(skb)->end_seq = seq;
}
\end{minted}

\subsection{before()和after()}
在一些需要判断序号前后的地方出现了\mintinline{c}{before()}和\mintinline{c}{after()}
这两个函数。这两个函数的定义如下
\begin{minted}[linenos]{c}
/* include/net/tcp.h
 * 比较两个无符号32位整数
 */
static inline bool before(__u32 seq1, __u32 seq2)
{
        return (__s32)(seq1-seq2) < 0;
}
#define after(seq2, seq1)       before(seq1, seq2)
\end{minted}
可以看到，这两个函数实际上就是将两个数直接相减。之所以要单独弄个函数应该是为了避免强制转型
造成影响。序号都是32位无符号整型。

\section{辅助函数}
有些小函数是用于辅助一些很底层的功能的，这里单独列出来。
                unlikely
\subsection{字节序}
CPU分为大端和小端两种。而在网络传输的过程中，大小端的不一致会带来问题。
因此，网络协议中对于字节序都有明确规定。一般采用大端序。

Linux中，对于这一部分的支持放在了\mintinline{text}{include/linux/byteorder/generic.h}
中。而实现，则交由体系结构相关的代码来完成。

\begin{minted}[linenos]{c}
/* 下面的函数用于进行对16位整型或者32位整型在网络传输格式和本地格式之间的转换。
 */
ntohl(__u32 x)
ntohs(__u16 x)
htonl(__u32 x)
htons(__u16 x)
\end{minted}

上面函数的命名规则是末尾的l代表32位，s代表16位。n代表network，h代表host。
根据命名规则，不难知道函数的用途。比如htons就是从本地的格式转换的网络传输用的格式，
转换的是16位整数。
