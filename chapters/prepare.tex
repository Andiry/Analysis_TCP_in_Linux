\chapter{准备部分}

\minitoc

\section{用户层TCP}

用户层的TCP编程模型大致如下，对于服务端，调用listen监听端口，
之后接受客户端的请求，然后就可以收发数据了。结束时，关闭socket。

\begin{minted}[linenos]{c}
// Server
socket(...,SOCK_STREAM,0);
bind(...,&server_address, ...);
listen(...);
accept(..., &client_address, ...);
recv(..., &clientaddr, ...);
close(...);
\end{minted}

对于客户端，则调用connect连接服务端，之后便可以收发数据。
最后关闭socket。

\begin{minted}[linenos]{c}
socket(...,SOCK_STREAM,0);
connect();
send(...,&server_address,...);
\end{minted}

那么根据我们的需求，我们着重照顾连接的建立、关闭和封包的收发过程。

\section{探寻tcp\_prot，地图get\textasciitilde{}}

一般游戏的主角手中，都会有一张万能的地图。为了搞定TCP，我们自然也是需要
一张地图的，要不连该去找那个函数看都不知道。很有幸，在\mintinline[linenos]{text}{tcp_ipv4.c}中，
\mintinline[linenos]{text}{tcp_prot}定义了\mintinline[linenos]{text}{tcp}的各个接口。

\mintinline[linenos]{text}{tcp_prot}的类型为\mintinline[linenos]{text}{struct proto}，是这个结构体是为了抽象各种不同的协议的
差异性而存在的。类似面向对象中所说的接口(Interface)的概念。这里，我们仅
保留我们关系的部分。

\begin{minted}[linenos]{c}
struct proto tcp_prot = {
        .name                   = "TCP",
        .owner                  = THIS_MODULE,
        .close                  = tcp_close,
        .connect                = tcp_v4_connect,
        .disconnect             = tcp_disconnect,
        .accept                 = inet_csk_accept,
        .destroy                = tcp_v4_destroy_sock,
        .shutdown               = tcp_shutdown,
        .setsockopt             = tcp_setsockopt,
        .getsockopt             = tcp_getsockopt,
        .recvmsg                = tcp_recvmsg,
        .sendmsg                = tcp_sendmsg,
        .sendpage               = tcp_sendpage,
        .backlog_rcv            = tcp_v4_do_rcv,
        .get_port               = inet_csk_get_port,
        .twsk_prot              = &tcp_timewait_sock_ops,
        .rsk_prot               = &tcp_request_sock_ops,
};
\end{minted}

通过名字，我大致筛选出来了这些函数，初步判断这些函数与实验所关心的功能相关。
对着这张``地图''，就可以顺藤摸瓜，找出些路径了。

先根据参考书《Linux内核源码剖析------TCP/IP实现》中给出的流程图，
找出所有和需求相关的部分。

首先找三次握手相关的部分：从客户端的角度，发起连接需要调用\mintinline[linenos]{text}{tcp_v4_connect}，
该函数会进一步调用\mintinline[linenos]{text}{tcp_connect}，在这个函数中，会调用\mintinline[linenos]{text}{tcp_send_syn_data}
发送SYN报文，并设定超时计时器。第二次握手相关的接收代码在\mintinline[linenos]{text}{tcp_rcv_state_process}中，
该函数实现了除\mintinline[linenos]{text}{ESTABLISHED}和\mintinline[linenos]{text}{TIME_WAIT}之外所有状态下的接收处理。
\mintinline[linenos]{text}{tcp_send_ack}函数实现了发送ACK报文。从服务端的角度，则还需实现\mintinline[linenos]{text}{listen}调用和
\mintinline[linenos]{text}{accept}调用。二者都是服务端建立连接所需要的部分。

封包的封装发送部分，所对应的函数是\mintinline[linenos]{text}{tcp_sendmsg}，实现对数据的复制、切割和发送。
TCP的重传接口为\mintinline[linenos]{text}{tcp_retransmit_skb}，这里尚有疑问，因为这个函数是负责处理重传的，
而不是判断是否应当重传的。所以并不明确到底是否该重新实现这一部分。

TCP封包的接收在\mintinline[linenos]{text}{tcp_rcv_established}函数中，根据目前有限的资料看，TCP的滑动窗口机制应该
在这一部分，更细节的内容待确认。

\begin{itemize}
\item
  tcp\_transmit\_skb
\item
  tcp\_rcv\_state\_process
\item
  tcp\_connect
\item
  tcp\_rcv\_synsent\_state\_process
\item
  tcp\_rcv\_established
\item
  tcp\_send\_ack
\item
  tcp\_sendmsg
\item
  tcp\_retransmit\_skb
\item
  tcp\_rcv\_established
\end{itemize}

\section{RFC}
\label{sec:rfc}

在分析TCP的过程中会遇到很多RFC，在这里，我们将可能会碰到的RFC罗列出来。
并进行一定的讨论。便于后面的分析。

\subsection{RFC793——Transmission Control Protocol}
\label{subsec:rfc793}

该RFC正是定义了TCP协议的那份RFC。在该RFC中，可以查到TCP的很多细节，帮助后续的代码分析。

\subsubsection{TCP头部格式}
\label{subsubsec:tcp_header_format}
RFC793中，对于TCP头部格式的描述摘录如下：
\begin{minted}[linenos]{text}
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format

          Note that one tick mark represents one bit position.
\end{minted}
这张图可以很方便地读出各个位占多长，它上面的标识是十进制的，很容易读。
这里我们挑出我们比较关心的Options字段来解读。因为很多TCP的扩展都是通过新增
选项来实现的。

选项总是在TCP头部的最后，且选项有两种格式：
\begin{enumerate}
\item 单独的一个字节，代表选项的类型例如：

\begin{minted}[linenos]{text}
  End of Option List
  +--------+
  |00000000| 
  +--------+ 
  Kind=0
\end{minted}

\item 第一个字节代表选项的类型，紧跟着的一个字节代表选项的长度，后面跟着
选项的数据。例如：

\begin{minted}[linenos]{text}
  Maximum Segment Size
  +--------+--------+---------+--------+ 
  |00000010|00000100| max seg size     | 
  +--------+--------+---------+--------+ 
    Kind=2  Length=4
\end{minted}

\end{enumerate}

\subsection{RFC1323——TCP Extensions for High Performance}
\label{subsec:rfc1323}

\subsubsection{简介}
\label{subsubsec:rfc1323_introduce}
这个RFC主要是在考虑高带宽高延迟网络下如何提升TCP的性能。该RFC定义了新的TCP选项，
以实现窗口缩放(window scaled)和时间戳(timestamp)。这里的时间戳可以用于实现
两个机制：RTTM(Round Trip Time Measurement)和PAWS(Protect Against Wrapped Sequences)。

在RFC1323中提出，在这类高带宽高延迟网络下，有三个主要的影响TCP性能的因素：
\begin{description}
  \item[窗口尺寸限制] 在TCP头部中，只有16位的一个域用于说明窗口大小。也就是说，
    窗口大小最大只能达到$2^{16}=64K字节$。解决这一问题的方案是增加一个窗口缩放
    选项，我们会在\ref{subsubsec:window_scale}中进一步讨论。
  \item[丢包后的恢复] 丢包会导致TCP重新进入慢启动状态，导致数据的流水线断流。
    在引入了快重传和快恢复后，可以解决丢包率为一个窗口中丢一个包的情况下的问题。
    但是在引入了窗口缩放以后，由于窗口的扩大，丢包的概率也随之增加。很容易使TCP进入
    到慢启动状态，影响网络性能。为了解决这一问题，需要引入SACK机制，但在这个RFC中，
    不讨论SACK相关的问题。
  \item[往返时间度量] RTO(Retransmission timeout)是TCP性能的一个很基础的参数。
    在RFC1323中介绍了一种名为RTTM的机制，利用一个新的名为Timestamps的选项来对时间
    进行进一步的统计。
\end{description}

\subsubsection{窗口缩放(Window Scale)}
\label{subsubsec:window_scale}
这一扩展将原有的TCP窗口扩展到32位。而根据RFC793中的定义，TCP头部描述窗口大小的域仅有16位。
为了将其扩展为32位，该扩展定义了一个新的选项用于表示缩放因子。这一选项仅会出现在SYN段，
此后，所有通过该连接的通信，其窗口大小都会受到这一选项的影响。

该选项的格式为：
\begin{minted}[linenos]{text}
  +---------+---------+---------+ 
  | Kind=3  |Length=3 |shift.cnt| 
  +---------+---------+---------+
\end{minted}

\mintinline{text}{kind}域为3，\mintinline{text}{length}域为3，后面跟着3个字节的
\mintinline{text}{shift.cnt}，代表缩放因子。TCP的Options域的选项的格式在
\ref{subsubsec:tcp_header_format}中已有说明。这里采用的是第二种格式。

在启用了窗口缩放以后，TCP头部中的接收窗口大小，就变为了真实的接收窗口大小右移
\mintinline{text}{shift.cnt}的值。RFC中对于该选项的实现的建议是在传输控制块中，
按照32位整型来存储所有的窗口值，包括发送窗口、接受窗口和拥塞窗口。

作为接收方，每当收到一个段时（除SYN段外），通过将发来的窗口值左移来得到正确的值。
\begin{minted}[linenos]{c}
SND.WND = SEG.WND << Snd.Wind.Scale
\end{minted}

作为发送方则每次在发包前，将发送窗口的值右移，然后再封装在封包中。
\begin{minted}[linenos]{c}
SEG.WND = RCV.WND >> Rcv.Wind.Scale
\end{minted}

\subsubsection{PAWS(Protect Against Wrapped Sequence Numbers)}
PAWS是一个用于防止旧的重复封包带来的问题的机制。它采用了TCP中的Timestamps选项。
该选项的格式为：
\begin{minted}[linenos]{text}
+-------+-------+---------------------+---------------------+ 
|Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)| 
+-------+-------+---------------------+---------------------+
    1       1              4                      4
\end{minted}
TSval(Timestamp Value)包含了TCP发送方的时钟的当前值。如果ACK位被设置了的话，
TSecr(Timestamp Echo Reply)会包含一个由对方发送过来的最近的时钟值。

PAWS的算法流程为：
\begin{enumerate}
  \item 如果当前到达的段SEG含有Timestamps选项，且SEG.TSval < TS.Recent且
该TS.Recent是有效的，那么则认为当前到达的分段是不可被接受的，需要丢弃掉。
  \item 如果段超过了窗口的范围，则丢弃它（与正常的TCP处理相同）
  \item 如果满足SEG.SEQ$\leqslant$Last.ACK.sent（最后回复的ACK包中的时间戳），
    那么，将SEG的时间戳记录为TS.Recent。
  \item 如果SEG是正常按顺序到达的，那么正常地接收它。
  \item 其他情况下，将该段视作正常的在窗口中，但顺序不正确的TCP段对待。
\end{enumerate}

\subsection{RFC3168}
\label{subsec:rfc3168}

