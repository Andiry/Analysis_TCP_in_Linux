\section{主动关闭}
\label{sec:tcp_active_close}

\subsection{第一次握手——发送FIN}
\label{subsec:tcp_shutdown}
通过shutdown系统调用，主动关闭TCP连接。该系统调用最终由\mintinline{c}{tcp_shutdown}实现。
代码如下：

\begin{minted}[linenos]{c}
void tcp_shutdown(struct sock *sk, int how)
{
        /*      We need to grab some memory, and put together a FIN,
         *      and then put it into the queue to be sent.
         *              Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec '92.
         */
        if (!(how & SEND_SHUTDOWN))
                return;

        /* 如果此时已经发送一个FIN了，就跳过。 */
        if ((1 << sk->sk_state) &
            (TCPF_ESTABLISHED | TCPF_SYN_SENT |
             TCPF_SYN_RECV | TCPF_CLOSE_WAIT)) {
                /* Clear out any half completed packets.  FIN if needed. */
                if (tcp_close_state(sk))
                        tcp_send_fin(sk);
        }
}
\end{minted}
该函数会在需要发送FIN时，调用\mintinline{c}{tcp_close_state()}来设置TCP的状态。
该函数会根据当前的状态，按照\ref{subsubsec:tcp_state_diagram}中给出的状态图。
\begin{minted}[linenos]{c}
static const unsigned char new_state[16] = {
  /* 当前状态:             新的状态:        动作:      */
  [0 /* (Invalid) */]   = TCP_CLOSE,
  [TCP_ESTABLISHED]     = TCP_FIN_WAIT1 | TCP_ACTION_FIN,
  [TCP_SYN_SENT]        = TCP_CLOSE,
  [TCP_SYN_RECV]        = TCP_FIN_WAIT1 | TCP_ACTION_FIN,
  [TCP_FIN_WAIT1]       = TCP_FIN_WAIT1,
  [TCP_FIN_WAIT2]       = TCP_FIN_WAIT2,
  [TCP_TIME_WAIT]       = TCP_CLOSE,
  [TCP_CLOSE]           = TCP_CLOSE,
  [TCP_CLOSE_WAIT]      = TCP_LAST_ACK  | TCP_ACTION_FIN,
  [TCP_LAST_ACK]        = TCP_LAST_ACK,
  [TCP_LISTEN]          = TCP_CLOSE,
  [TCP_CLOSING]         = TCP_CLOSING,
  [TCP_NEW_SYN_RECV]    = TCP_CLOSE,    /* should not happen ! */
};

static int tcp_close_state(struct sock *sk)
{
        int next = (int)new_state[sk->sk_state];
        int ns = next & TCP_STATE_MASK;

        /* 根据状态图进行状态转移 */
        tcp_set_state(sk, ns);

        /* 如果需要执行发送FIN的动作，则返回真 */
        return next & TCP_ACTION_FIN;
}
\end{minted}
可以看出，只有当当前状态为TCP\_ESTABLISHED、TCP\_SYN\_RECV、TCP\_CLOSE\_WAIT时，
需要发送FIN包。这个也和TCP状态图一致。如果需要发送FIN包，则会调用
\mintinline{c}{tcp_send_fin}。
\begin{minted}[linenos]{c}
void tcp_send_fin(struct sock *sk)
{
        struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);
        struct tcp_sock *tp = tcp_sk(sk);

        /* 这里做了一些优化。如果发送队列的末尾还有段没有发出去，则利用该段发送FIN。 */
        if (tskb && (tcp_send_head(sk) || tcp_under_memory_pressure(sk))) {
          /* 如果当前正在发送的队列不为空，或者当前TCP处于内存压力下，则进行该优化 */
coalesce:
                TCP_SKB_CB(tskb)->tcp_flags |= TCPHDR_FIN;
                TCP_SKB_CB(tskb)->end_seq++;
                tp->write_seq++;
                if (!tcp_send_head(sk)) {
                        /* This means tskb was already sent.
                         * Pretend we included the FIN on previous transmit.
                         * We need to set tp->snd_nxt to the value it would have
                         * if FIN had been sent. This is because retransmit path
                         * does not change tp->snd_nxt.
                         */
                        tp->snd_nxt++;
                        return;
                }
        } else {
                /* 为封包分配空间 */
                skb = alloc_skb_fclone(MAX_TCP_HEADER, sk->sk_allocation);
                if (unlikely(!skb)) {
                        /* 如果分配不到空间，且队尾还有未发送的包，利用该包发出FIN。 */
                        if (tskb)
                                goto coalesce;
                        return;
                }
                skb_reserve(skb, MAX_TCP_HEADER);
                sk_forced_mem_schedule(sk, skb->truesize);
                /* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
                /* 构造一个FIN包，并加入发送队列。 */
                tcp_init_nondata_skb(skb, tp->write_seq,
                                     TCPHDR_ACK | TCPHDR_FIN);
                tcp_queue_skb(sk, skb);
        }
        __tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);
}
\end{minted}
在函数的最后，将所有的剩余数据一口气发出去，完成发送FIN包的过程。至此，主动关闭过程的
第一次握手完成。

\subsection{第二次握手——接受ACK}
在发出FIN后，接收端会回复ACK确认收到了请求。从这里开始有两种情况，这里先考虑教科书式
的四次握手的情况。双方同时发出FIN的情况会在\ref{subsec:fin_at_same_time}中描述。
根据状态图，主动发出FIN包后，会进入\mintinline{text}{FIN_WAIT1}状态。根据这一信息，
可以从\mintinline{c}{tcp_rcv_state_process}中，找到相应的代码。
\begin{minted}[linenos]{c}
int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)
{
        struct tcp_sock *tp = tcp_sk(sk);
        struct inet_connection_sock *icsk = inet_csk(sk);
        const struct tcphdr *th = tcp_hdr(skb);
        struct request_sock *req;
        int queued = 0;
        bool acceptable;

        tp->rx_opt.saw_tstamp = 0;
        switch (sk->sk_state) {
        case TCP_CLOSE:
                goto discard;

        case TCP_LISTEN:
                /* LISTEN状态处理代码，略去 */

        case TCP_SYN_SENT:
                /* SYN-SENT状态处理代码，略去 */
        }

        /* fastopen相关代码及各类合法性判断，略去 */

        switch (sk->sk_state) {
        case TCP_SYN_RECV:
                /* SYN-RECV状态处理代码，略去 */
        
        case TCP_FIN_WAIT1: {
                struct dst_entry *dst;
                int tmo;

                /* 如果当前的套接字为开启了Fast Open的套接字，且该ACK为
                 * 接收到的第一个ACK，那么这个ACK应该是在确认SYNACK包，
                 * 因此，停止SYNACK计时器。
                 */
                if (req) {
                        /* Return RST if ack_seq is invalid.
                         * Note that RFC793 only says to generate a
                         * DUPACK for it but for TCP Fast Open it seems
                         * better to treat this case like TCP_SYN_RECV
                         * above.
                         */
                        if (!acceptable)
                                return 1;
                        /* 移除fastopen请求 */
                        reqsk_fastopen_remove(sk, req, false);
                        tcp_rearm_rto(sk);
                }
                if (tp->snd_una != tp->write_seq)
                        break;

                /* 收到ACK后，转移到TCP_FIN_WAIT2状态，将发送端关闭。 */
                tcp_set_state(sk, TCP_FIN_WAIT2);
                sk->sk_shutdown |= SEND_SHUTDOWN;

                /* 确认路由缓存有效 */
                dst = __sk_dst_get(sk);
                if (dst)
                        dst_confirm(dst);

                /* 唤醒等待该套接字的进程 */
                if (!sock_flag(sk, SOCK_DEAD)) {
                        /* Wake up lingering close() */
                        sk->sk_state_change(sk);
                        break;
                }

                /* 如果所有发送的字节都被确认了，那么进入关闭状态。 */
                if (tp->linger2 < 0 ||
                    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
                     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {
                        tcp_done(sk);
                        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
                        return 1;
                }
\end{minted}
转换到\mintinline{c}{TCP_FIN_WAIT2}以后，计算接受fin包的超时时间。
如果还能留出TIMEWAIT阶段的时间（TIMEWAIT阶段有最长时间限制），那么在此之前，
就激活保活计时器保持连接。如果时间已经不足了，就主动调用\mintinline{c}{tcp_time_wait}
进入TIMEWAIT状态。
\begin{minted}[linenos]{c}
                tmo = tcp_fin_time(sk);
                if (tmo > TCP_TIMEWAIT_LEN) {
                        inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);
                } else if (th->fin || sock_owned_by_user(sk)) {
                        /* Bad case. We could lose such FIN otherwise.
                         * It is not a big problem, but it looks confusing
                         * and not so rare event. We still can lose it now,
                         * if it spins in bh_lock_sock(), but it is really
                         * marginal case.
                         */
                        inet_csk_reset_keepalive_timer(sk, tmo);
                } else {
                        /* 进入TCP_FIN_WAIT2状态等待。 */
                        tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);
                        goto discard;
                }
                break;

                /* 其余状态处理代码，略去 */
        }

        /* step 6: check the URG bit */
        tcp_urg(sk, skb, th);

        /* step 7: process the segment text */
        switch (sk->sk_state) {
          /* 其他状态处理代码，略去 */

        case TCP_FIN_WAIT1:
        case TCP_FIN_WAIT2:
                /* RFC 793 says to queue data in these states,
                 * RFC 1122 says we MUST send a reset.
                 * BSD 4.4 also does reset.
                 */
                if (sk->sk_shutdown & RCV_SHUTDOWN) {
                        if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
                            after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {
                                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
                                /* 如果接收端已经关闭了，那么发送RESET。 */
                                tcp_reset(sk);
                                return 1;
                        }
                }
                /* Fall through */

           /* 其他状态处理代码，略去 */
        }

        /* tcp_data could move socket to TIME-WAIT */
        if (sk->sk_state != TCP_CLOSE) {
                tcp_data_snd_check(sk);
                tcp_ack_snd_check(sk);
        }

        if (!queued) {
discard:
                __kfree_skb(skb);
        }
        return 0;
}
\end{minted}
执行完该段代码后，则进入了\mintinline{text}{FIN_WAIT2}状态。

\subsection{FIN\_WAIT2}

\subsection{CLOSING}

\subsection{TIME\_WAIT}

\subsection{同时打开}
\label{subsec:fin_at_same_time}
